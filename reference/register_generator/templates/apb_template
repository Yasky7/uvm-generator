//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
// Abstract : AMBA APB slave
//            slave is always ready and response is always OKAY.
//NAME : {{ip_name}}
//CONFIG: ADDR_WIDTH:{{addr_width}}  DATA_WIDTH:{{data_width}}  REG_WIDTH:{{reg_width}}
{% for item in items-%}
//REG_NAME: {{item.reg_name}}  REG_TYPE: {{item.type}}
{% endfor-%}
//-----------------------------------------------------------------------------
module {{ip_name}}
  (input  wire                   PCLK,    // clock
  input  wire                    PRESETN, // reset
  // apb interface inputs
  input  wire                    PSEL,
  input  wire  [{{addr_width-1}}:0]             PADDR,
  input  wire                    PENABLE ,
  input  wire                    PWRITE,
  input  wire  [{{data_width-1}}:0]             PWDATA,
  // Data register read/write interface
  output reg   [{{data_width-1}}:0]             PRDATA,
  output wire                    PREADY,
  output wire                    PSLVERR);  
  wire                     read_en; 
  wire                     write_en; 
// register read and write signal
assign   PREADY  = 1'b1; 
assign   PSLVERR = 1'b0;  
assign   read_en  = PSEL & (~PWRITE); // assert for whole apb read transfer
assign   write_en = PSEL & (~PENABLE) & PWRITE; // assert for 1st cycle of write transfer
        // It is also possible to change the design to perform the write in the 2nd
        // APB cycle.   E.g.
        //   assign write_en = psel & penable & pwrite;
        // However, if the design generate waitstate, this expression will result
        // in write_en being asserted for multiple cycles.
// Data register
{% for item in items-%}
 reg     [{{reg_width-1}}:0]            {{item.reg_name}};
{% endfor%}
//------------------------------------------------------------------------------
 // module logic start
 //------------------------------------------------------------------------------
//write logic 
always @(posedge PCLK or negedge PRESETN) 
      begin 
         if (~PRESETN) 
            begin   
            {% for item in items-%}
            {{item.reg_name}} <={{reg_width}}'d0;// Reset data to 0x00000000
            {% endfor%}		
	  end 
         else if (write_en) 
            begin 
                    case(PADDR)
					{% for item in items if (item.type=="RW" or item.type=="WO") -%}
				     {% for i in range(0,reg_width,data_width)-%}
					   {{addr_width}}'d{{item.addr+loop.index-1}}: {{item.reg_name}}[{{data_width+i-1}}:{{i}}]<= PWDATA;  //Write data to {{addr_width}}'d{{item.addr+loop.index-1}}
				     {%endfor%}
					{%endfor-%}
				endcase
            end 
				{% for item in items if item.type=="RC" -%}
				{% if (loop.first==True) -%}
		else if (read_en)
	        begin
				case(PADDR)		
				{% endif -%}	
				  {% for i in range(0,reg_width,data_width) -%}
				   {{addr_width}}'d{{item.addr+loop.index-1}}: {{item.reg_name}}[{{data_width+i-1}}:{{i}}]<= 0; //Clear the data
				  {%endfor%}
				{% if (loop.last==True) -%}
		endcase
			end
				{% endif-%}  
	            {% endfor-%}
		else       
		     begin
			 {% for item in items-%}
             {{item.reg_name}} <=  {{item.reg_name}};  // default
             {% endfor%}
			  end
  end
//read logic
always@(posedge PCLK or negedge PRESETN)
begin
	if(!PRESETN)
	begin
		PRDATA <={{data_width}}'d0;
	end
	else
	begin
		if(read_en)
		begin
			case(PADDR)
				{% for item in items if (item.type=="RW" or item.type=="RO" or item.type=="RC") -%}
					{% for i in range(0,reg_width,data_width) -%}
						{{addr_width}}'d{{item.addr+loop.index-1}}: PRDATA <={{item.reg_name}}[{{data_width+i-1}}:{{i}}];  //Read data from {{addr_width}}'d{{item.addr+loop.index}}
					{%endfor%}
	            {%endfor-%}
				default: PRDATA <= {{data_width}}'d0;   // default
			endcase
		end	
		else
		begin
  	 		 PRDATA <= {{data_width}}'d0; // default
	 	end
	end
end



{% if (assertion==True) -%}
`ifdef APB_ASSERT_ON

 `include "std_ovl_defines.h"
  // ------------------------------------------------------------
  // Assertions
  // ------------------------------------------------------------

  // Check error response should not be generated if not selected
    assert_never
     #(`OVL_ERROR,
       `OVL_ASSERT,
       "Error! Should not generate error response if not selected")
     u_ovl_apb_slave_response_illegal
     (.clk        (PLCK),
      .reset_n    (PRESETN),
      .test_expr  (PSLVERR & PREADY & (~PSEL))
      );


   // Check the write_en signal generated
    assert_implication
    #(`OVL_ERROR,
      `OVL_ASSERT,
      "Error! register write signal was not generated! "
      )
     u_ovl_apb_slave_reg_write
     (.clk             (PCLK),
      .reset_n         (PRESETn),
      .antecedent_expr ( (PSEL & (~PENABLE) & PWRITE) ),
      .consequent_expr ( write_en == 1'b1)
      );



  // Check the read_en signal generated
    assert_implication
    #(`OVL_ERROR,
      `OVL_ASSERT,
      "Error! register read signal was not generated! "
      )
     u_ovl_apb_slave_reg_read
     (.clk             (PCLK),
      .reset_n         (PRESETn),
      .antecedent_expr ( (PSEL & (~PENABLE) & (~PWRITE)) ),
      .consequent_expr ( read_en == 1'b1)
      );


  // Check register read and write operation won't assert at the same cycle
    assert_never
     #(`OVL_ERROR,
       `OVL_ASSERT,
       "Error! register read and write active at the same cycle!")
     u_ovl_apb_slave_rd_wr_illegal
     (.clk        (PCLK),
      .reset_n    (PRESETn),
      .test_expr  ((write_en & read_en))
      );



`endif
{%endif-%}
 //------------------------------------------------------------------------------
 // module logic end
 //------------------------------------------------------------------------------

 endmodule		
					
					
